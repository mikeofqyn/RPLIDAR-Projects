#include <RPLidar.h>    // Robopeak's library for SLAMTEC RPLIDAR A1 
#include <HardwareSerial.h>
 
/****************************************************************************** 
 * Use an ESP32 board to collect data from a RPLIDAR A1 rotating lidar and send 
 * them through UDP for processing on another node.
 * 
 * 20 Mar 2022 by Miguel de Reyna (https://github.com/mikeofqyn)
 * 
 * Connections:
 * ============
 * 
 * This sketch uses the default pin assignments for the second UART (UART2)  
 * (16-RX, 17, TX) This may be changed in the begin() method of the serial 
 * object. See
 * https://forum.dronebotworkshop.com/esp32-esp8266/esp-32-serial1-or-serial2-map-to-different-pins-than-default/
 * https://github.com/G6EJD/ESP32-Using-Hardware-Serial-Ports/blob/master/ESP32_Using_Serial2.ino
 * 
 * 
 *  ESP32                  RPLIDAR          EXT. 5V SUPPLY
 *  ---------              ----------       --------------
 *  IO16 (RX)   -------->  TX
 *  IO17 (TX)   -------->  RX
 *  5V          -------->  SIGNAL VIN
 *  GND         -------->  SIGNAL GND
 *  (SEE NOTE)  -------->  MOTOCTL                         
 *                         MOTOR VIN -----> 5V OUT
 *  GND         -------->  MOTOR GND -----> GND
 *                        
 * NOTE:      
 * =====
 * The RPLIDAR's motor is powered with 5V with a 0-5 V motor speed signal. 
 * This sketch allows for a PWM signal to be generated by defining its pin
 * number in the symbol RPLIDAR_MOTOR_PWM_PIN. If not defined then no control
 * signal is generated. The MOTO_CTL input of the RPLIDAR A1 can be safely tied 
 * to +5V for maximum speed, directly or though a potentiometer. If using the 
 * RPLIDAR_MOTOR_PWM_PIN, then some method of voltage level shift should be used. 
 * 
 * 
 * RPLidar library and code snippets Copyright (c) 2014, RoboPeak
 *    https://RoboPeak.com
 *    
 */

// *****************************************************************************
// LIMITS
// *****************************************************************************

const unsigned int MAX_DAC_VALUE = 4096;  // MCP4725 is a 12-bit DAC 
const int MIN_QUALITY = 0;          // Points below this quality level are ingnored
const float MAX_DIST_MM = 12000.0;  // Max distance to consider
const float MIN_DIST_MM = 50.0;     // min valid distance

// *****************************************************************************
// CONFIGURATION 
// *****************************************************************************
  

#define RPLIDAR_LOG_LEVEL 1

#include <RPLIDAR_utils.h>

RPLIDAR_Packet messageData;

static unsigned long total_points = 0;
static unsigned long good_points = 0;
static unsigned long consecutive_errors = 0;
static unsigned long total_errors = 0;

// *****************************************************************************
// RPLIDAR A1
// *****************************************************************************
//  
// Create a driver instance 
//
RPLidar lidar;

// PWM pin controlling RPLIDAR's motor speed. Connect to RPLIDAR's MOTOCTRL signal 
// Motor speed (PWM value). Minumim about 140, max 255 (100%)

// #define RPLIDAR_MOTOR_PWM_PIN 3  // Define only if 5V-capable PWM pin is available

#define RPLIDAR_MOTOR_SPEED 1000    // only used if RPLIDAR_MOTOR_PWM_PIN is defined

// Use an alternate UART to communicate with the RPLIDAR. 'Serial' is used for 
// debugging and logging.

#define RXPIN  4 // Patch - Default 16 (Error in wiring) See begin()
#define TXPIN 16 // Patch - Default 17
HardwareSerial SerialTwo(2);  // ESP32: UART(2) pins 16-RX, 17-TX by default

// EMULATE UNO'S PWM BEHAVIOUR ON ESP32 (needs voltage level shifter)
#ifdef RPLIDAR_MOTOR_PWM_PIN
const int freq = 1000;
const int ledChannel = 0;
const int resolution = 8;
void init_pwm() { 
    ledcSetup(ledChannel, freq, resolution);
    ledcAttachPin(RPLIDAR_MOTOR_PWM_PIN, ledChannel);
}
void set_speed(int dutyCycle) {
    ledcWrite(ledChannel, dutyCycle);
}
#else
void init_pwm() {  }
void set_speed(int dummy) { }
#endif

// *************************************************************************************
// SET UP
// *************************************************************************************
void setup()
{
  rplidar_set_log_level(RPLIDAR_LOG_LEVEL);
  //
  // initialize serial console if available
  //
  r_serial_begin(115200);
  r_serial_println("\n\n");
  delay(400);
  r_serial_println("\n\n\n\n\n\n\n\n");
  r_serial_println("Initializing RPLIDAR driver\n");

  // 
  // WiFi
  //
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  // Connecting to WiFi...
  r_serial_print("Connecting to " WIFI_SSID " ");
  // Loop continuously while WiFi is not connected
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    r_serial_print(".");
  }
  r_serial_print("  IP Address: ");
  r_serial_println(WiFi.localIP().toString());

  messageData.fromIP  = (uint32_t) WiFi.localIP();
  messageData.fromId  = RPLIDAR_1;

  //  
  // RPLidar
  //
  RPLIDAR_packet_init(messageData, RPLIDAR_DATA, RPLIDAR_1, (uint32_t) WiFi.localIP());
  lidar.begin(SerialTwo);
  init_pwm();

#if (RPLIDAR_LOG_LEVEL == 2)
  r_serial_println("sent\tseq\tangle\tdistance\tstart\tQ");
#endif  
  
}


// *************************************************************************************
// LOOP
// *************************************************************************************
void loop()
{
  //
  // Get next point
  //
  if (IS_OK(lidar.waitPoint())) {
    total_points++;
    messageData.packetType = RPLIDAR_DATA;
    RPLidarMeasurement M = lidar.getCurrentPoint();
    messageData.distance = M.distance;  // distance value in mm 
    messageData.angle    = M.angle;     // anglue value in degrees
    messageData.startBit = M.startBit;  // whether this point marks a new scan
    messageData.quality  = M.quality;   // quality of the current measurement
    // 
    // Filter out unwanted data
    //
    bool packet_to_send = true;
    if ( (messageData.quality  < MIN_QUALITY) ||
         (messageData.distance > MAX_DIST_MM) || 
         (messageData.distance < MIN_DIST_MM) ) {
      packet_to_send = false;
    } else {
        messageData.seqnNumber++;
    }
    //
    // Build packet and send
    //
    if (packet_to_send) {
      good_points++;
      messageData.onTimeMillis = millis();
      UDP.beginPacket(RPLIDAR_BROADCAST_ADDRESS, UDP_PORT) &&
        UDP.write((const unsigned char *)&messageData, sizeof(messageData)) &&
          UDP.endPacket();
      consecutive_errors = 0;
    }
  } else {    
    //
    // LIDAR NOT READY.
    //
    #if (RPLIDAR_LOG_LEVEL > 0)    
    r_serial_println("Waiting for RPLIDAR");
    #endif
    set_speed(0); //stop the rplidar motor
    // try to detect RPLIDAR... 
    rplidar_response_device_info_t info;
    bool detected = IS_OK(lidar.getDeviceInfo(info, 100));
    if (detected) {
       // detected...
       lidar.startScan();
       // start motor rotating at configured speed
       set_speed(RPLIDAR_MOTOR_SPEED);  
       delay(1000);
    }
    //
    // Send debug packet
    //
    packet_type_t tmp_type = messageData.packetType;
    (messageData.seqnNumber)++;
    messageData.onTimeMillis = millis();
    messageData.packetType = DEBUG_DATA;
    messageData.distance = ++consecutive_errors;
    messageData.angle    = ++total_errors;
    messageData.startBit = detected;
    messageData.quality  = 0;    
    UDP.beginPacket(RPLIDAR_BROADCAST_ADDRESS, UDP_PORT) &&
      UDP.write((const unsigned char *)&messageData, sizeof(messageData)) &&
       UDP.endPacket();
    messageData.packetType = tmp_type;
    r_serial_println("debug packet sent");
  }
  //
  // Log
  //
  float percent_good = 100.0 * ((float)good_points/total_points);
  rplidar_log_data(messageData, percent_good);
}
